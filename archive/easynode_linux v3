#!/bin/bash

# Définition unique des couleurs et du style
declare -A COLORS=(
    ["PRIMARY"]='\033[38;5;255m'    # Blanc normal
    ["SUCCESS"]='\033[38;5;71m'     # Vert apaisant
    ["MONERO"]='\033[38;5;208m'     # Orange monero
    ["WARNING"]='\033[38;5;184m'    # Jaune doux
    ["ERROR"]='\033[38;5;167m'      # Rouge atténué
    ["INFO"]='\033[38;5;74m'        # Bleu clair
    ["HEADER"]='\033[38;5;140m'     # Violet clair pour les titres
    ["BG"]='\033[48;5;16m'          # Noir encore plus profond
    ["RESET"]='\033[0m'             # Reset
    ["GRIS"]='\033[38;5;245m'       # GRIS
)

declare -A COLORS=(
    ["PRIMARY"]='\033[38;5;255m'    # Blanc normal
    ["SUCCESS"]='\033[38;5;71m'     # Vert apaisant
    ["MONERO"]='\033[38;5;208m'     # Orange monero
    ["WARNING"]='\033[38;5;184m'    # Jaune doux
    ["ERROR"]='\033[38;5;167m'      # Rouge atténué
    ["INFO"]='\033[38;5;74m'        # Bleu clair
    #["BG"]='\033[48;5;0m'           # Fond noir (modifié)
    ["BG"]='\033[48;5;16m'           # Noir encore plus profond
    #["BG"]='\033[48;2;0;0;0m'       # Noir absolu RGB
    ["GRIS"]='\033[38;5;245m'        # GRIS
    # ... autres couleurs ...
)

# Fonction pour dessiner la bannière
draw_banner() {
    tput sc
    tput cup 0 0
    echo -e "\033[38;5;208m"
    echo "  *     *   ***   *   * ***** ****   ***   "
    echo "  **   **  *   *  **  * *     *   * *   *  "
    echo "  * * * * *     * * * * ****  ****  *   *  "
    echo "  *  *  * *     * *  ** *     * *   *   *  "
    echo "  *     *  *   *  *   * *     *  *  *   *  "
    echo "  *     *   ***   *   * ***** *   *  ***   "
    echo "  ═══════════ ▌EASYNODE▐ ═══════════linux"
    #echo "  ═══════════ EASYNODE ═══════════v1linux  "
    echo -e "${COLORS[RESET]}"
    tput rc
}

# Variables globales
USERNAME=""
LANG_CHOICE=""
BLOCKCHAIN_TYPE=""
MONERO_VERSION="0.18.4.0"

# Fonction d'affichage stylisé 
print_styled() {
    local style=$1
    local message=$2
    echo -e "${COLORS[$style]}${message}${COLORS[RESET]}"
}
# Fonction pour les messages d'information
info() {
    print_styled "INFO" "ℹ $1"
}

# Messages d'erreur
error() {
    print_styled "ERROR" "✖ $1"
}

# Messages d'avertissement
warning() {
    print_styled "WARNING" "⚠ $1"
}

# Messages de succès
success() {
    print_styled "SUCCESS" "✓ $1"
}


# Fonction pour afficher les en-têtes
print_header() {
    local message=$1
    local length=${#message}
    local total_width=37    # Largeur totale de la ligne
    local line="═════════════════════════════════════════"
    local padding=$(( (total_width - length) / 2 ))
    local spaces=$(printf '%*s' $padding '')
    echo
    print_styled "MONERO" "$line"
    print_styled "HEADER" "${spaces}${message}"
    print_styled "MONERO" "$line"
    echo
}

# Configuration du terminal
setup_terminal() {
    echo -e "${COLORS[BG]}"
    clear
    printf '\033]11;#1a1a1a\007'
    draw_banner
}
# Messages d'information
info() {
    print_styled "INFO" "ℹ $1"
}

# Messages d'erreur
error() {
    print_styled "ERROR" "✖ $1"
}

# Messages d'avertissement
warning() {
    print_styled "WARNING" "⚠ $1"
}

# Messages de succès
success() {
    print_styled "SUCCESS" "✓ $1"
}

# Sélection de la langue
select_language() {
    clear
    draw_banner
    echo -e "\n\n\n\n\n\n\n\n"  # Ajoute de l'espace après la bannière
    print_header "LANGUAGE SELECTION"
                  
    while true; do
        print_styled "PRIMARY" "1) Français"
        print_styled "PRIMARY" "2) English"
        echo -n "$(print_styled "MONERO" "Choose/Choisissez (1-2): ")"    
            
        read -r lang_choice
        case $lang_choice in
            1) LANG_CHOICE="FR"; break ;;
            2) LANG_CHOICE="EN"; break ;;
            *) error "Invalid choice / Choix invalide" ;;    
        esac
      done
}

# Fonction pour obtenir les messages selon la langue
get_message() {
    local fr_msg=$1
    local en_msg=$2
    if [ "$LANG_CHOICE" = "FR" ]; then
        echo "$fr_msg"
    else
        echo "$en_msg"
    fi
}
 #manuel
 Manuel() {
    clear
    setup_terminal
    echo -e "\n\n\n\n\n\n\n\n"  # Espace pour la bannière
    print_header "$(get_message "GUIDE" "HOW TO")"
   
    print_styled "MONERO" "$(get_message "Pour une installation complète, suivez ces étapes dans l'ordre:" "For a complete installation, follow these steps in order:")"
    echo
         print_styled "SUCCESS" "$(get_message "  1️⃣ ➜ 2️⃣ ➜ 3️⃣ ➜ 4️⃣ ➜ 5️⃣." "  1️⃣ ➜ 2️⃣ ➜ 3️⃣ ➜ 4️⃣ ➜ 5️⃣.")"
   echo
   print_styled "SUCCESS" "$(get_message "  Puis au choix :" "  Then your choice :")"
   echo
   print_styled "SUCCESS" "$(get_message "  ▶️ Disque interne : étape 6️⃣." "  ▶️ Internal disk : stape 6️⃣.")"
   echo
   print_styled "SUCCESS" "$(get_message "  ▶️ Disque externe : étape 8️⃣ puis 6️⃣." "  ▶️ External disk : stape 8️⃣ then 6️⃣.")"
   echo
   print_header "$(get_message "AUTRES" "OTHER")"
   print_styled "GRIS" "$(get_message "  ➡️ Étape 6 : Démarrer le nœud et configurer l'exclusion des ⛔ 'IP bannis '." "  ➡️ stape6: Start the Node and introduce the exclusion of the ⛔ 'listed IP bans'.")"
   echo
   print_styled "GRIS" "$(get_message "  ➡️ Étape 9 : Démonter la blockchain du disque externe," "  ➡️ Stape 9 : Is used to unmount the blockchain from the external disk,")"
   print_styled "GRIS" "$(get_message "  ↳ Pour revenir au disque interne : passez à l'étape 6." "  ↳ Return on internal disk: then stape 6.")"
   echo
   print_styled "GRIS" "$(get_message "  ➡️ Étape 4 : Sert aussi pour le DEBUG du chemin d'amorçage du disque interne." "  ➡️ Stape 4 : Also serves as DEBUG of the boot path to internal disk.")"
   echo
   print_styled "PRIMARY" "$(get_message "   CTRL+C 1 seule fois pour arreter la Blockchain et revenir au menu." "  -CTRL+C 1 time only to stop the Blockchain and return to the menu.")"
   echo
   print_styled "WARNING" "$(get_message "⚠️ Important: REDIRIGER le port 22 et 18080 de votre Box internet" "⚠️ Important: REDIRECT port 22 and 18080 from your internet router")"
   print_styled "WARNING" "$(get_message "  vers l'adresse 'ip local' de votre PC" "  to your 'local ip' of your PC")"
   echo
    read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour revenir au menu..." "Press Enter to return to menu...")")"
}
# Sélection du type de blockchain
select_blockchain_type() {
    print_header "$(get_message "TYPE DE BLOCKCHAIN" "BLOCKCHAIN TYPE")"
    
        print_styled "PRIMARY" "$(get_message "1) Complète 220 Go" "1) Complete 220 Go")"
        print_styled "PRIMARY" "$(get_message "2) Prune 90 Go" "2) Pruned 90 Go")"
        echo -n "$(print_styled "INFO" "$(get_message "Choix (1-2): " "Choice (1-2): ")")"
        read -r choice
        case $choice in
            1) BLOCKCHAIN_TYPE="complete"; return 0  ;;
            2) BLOCKCHAIN_TYPE="pruned"; return 0 ;;
            *) 
            error "$(get_message "Choix invalide" "Invalid choice")" 
            return 1;;
        esac
    
}

update_system() {
    print_header "$(get_message "MISE À JOUR DU SYSTÈME" "SYSTEM UPDATE")"
    
    # Mise à jour initiale du système
    info "$(get_message "Mise à jour initiale du système..." "Initial system update...")"
    sudo apt update && sudo apt upgrade -y

    # Outils système essentiels
    info "$(get_message "Installation des outils système essentiels..." "Installing essential system tools...")"
    sudo apt install -y \
        build-essential \
        software-properties-common \
        apt-transport-https \
        ca-certificates \
        curl \
        wget \
        git \
        gnupg \
        lsb-release

    # Outils de compression
    info "$(get_message "Installation des outils de compression..." "Installing compression tools...")"
    sudo apt install -y \
        bzip2 \
        libbz2-dev \
        zip \
        unzip \
        tar \
        gzip

    # Outils réseau
    info "$(get_message "Installation des outils réseau..." "Installing network tools...")"
    sudo apt install -y \
        net-tools \
        openssh-server \
        ufw \
        fail2ban \
        nmap \
        tcpdump \
        htop \
        iftop \
        iotop


    # Activation et configuration de SSH
    info "$(get_message "Configuration de SSH..." "Configuring SSH...")"
    sudo systemctl enable ssh
    sudo systemctl start ssh
    
    # Configuration de sshd_config
info "$(get_message "Configuration du fichier SSH..." "Configuring SSH file...")"
echo "Port 22" | sudo tee /etc/ssh/sshd_config
echo "ListenAddress 0.0.0.0" | sudo tee -a /etc/ssh/sshd_config
echo "PasswordAuthentication yes" | sudo tee -a /etc/ssh/sshd_config

    # Outils de développement Python
    info "$(get_message "Installation des outils Python..." "Installing Python tools...")"
    sudo apt install -y \
        python3 \
        python3-pip \
        python3-dev

    # Éditeurs de texte
    info "$(get_message "Installation des éditeurs..." "Installing text editors...")"
    sudo apt install -y \
        vim \
        nano

    # Configuration du pare-feu UFW
    info "$(get_message "Configuration du pare-feu..." "Configuring firewall...")"
    sudo ufw --force reset
    sudo ufw disable
    sudo ufw allow 22
    sudo ufw allow 80
    sudo ufw allow 443
    sudo ufw allow 9050
    sudo ufw allow 18080:18090/tcp
    sudo ufw allow 18080:18090/udp
    sudo ufw allow 4200
    sudo ufw allow 4444 # i2p http
    sudo ufw allow 4447 # i2p socks
    sudo ufw allow 53317/tcp #localsend
    sudo ufw allow 53317/udp #localsend
    sudo ufw --force enable
   

    # Configuration de fail2ban
    info "$(get_message "Configuration de fail2ban..." "Configuring fail2ban...")"
    sudo systemctl enable fail2ban
    sudo systemctl start fail2ban

    # Nettoyage final
    info "$(get_message "Nettoyage du système..." "System cleanup...")"
    sudo apt autoremove -y
    sudo apt clean

    success "$(get_message "Mise à jour terminée" "Update completed")"
    read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
}
# Fonction pour ajouter les IPs bannies à bitmonero.conf

####################
# Créer le contenu du motd de manière dynamique
HOSTNAME=$(hostname)
IP_ADDRESS=$(hostname -I | cut -d' ' -f1)
SYSTEM_INFO=$(uname -s)" "$(uname -r)

# Utiliser echo -e pour interpréter les codes de couleur
echo -e "\e[0;33;38;5;208m  *     *   ***   *   * ***** ****   ***   
  **   **  *   *  **  * *     *   * *   *  
  * * * * *     * * * * ****  ****  *   *  
  *  *  * *     * *  ** *     * *   *   *  
  *     *  *   *  *   * *     *  *  *   *  
  *     *   ***   *   * ***** *   *  ***   
  ═════════════ ▌EASYNODE▐ ═════════Linux\e[0m

\e[0;33;38;5;208m    ▐ EASYNODE               EASYNODE▐ \e[0m

\e[1;34mNode Status:\e[0m
- Hostname: $HOSTNAME
- IP Address: $IP_ADDRESS
- Monero Version: $MONERO_VERSION
- System: $SYSTEM_INFO

\e[1;33mUseful Commands:\e[0m
- monerod --help : Show Monero daemon help
- monero-wallet-cli --help : Show wallet CLI help

\e[1;31mImportant:\e[0m
- Start monero: monerod
- Stop  monero: CTRL+C
- Check status: monerod status" | sudo tee /etc/motd > /dev/null
####################
# Demande du nom d'utilisateur
ask_username() {
clear
    setup_terminal
    echo -e "\n\n\n\n\n\n\n\n"  # Espace pour la bannière

    print_header "$(get_message "CONFIGURATION UTILISATEUR" "USER CONFIGURATION")"
    
    local current_user=""
    if [ -n "$SUDO_USER" ]; then
        current_user="$SUDO_USER"
    elif [ -n "$USER" ]; then
        current_user="$USER"
    else
        current_user=$(whoami)
    fi
    
    echo -e "$(get_message "Utilisateur détecté: " "Detected user: ")${COLORS[SUCCESS]}${current_user}${COLORS[RESET]}"
    echo
    
    print_styled "INFO" "$(get_message "Appuyez sur Entrée pour confirmer ou tapez un autre nom d'utilisateur: " "Press Enter to confirm or type another username: ")"
    read -r input_username
    
    if [ -z "$input_username" ]; then
        input_username="$current_user"
        USERNAME="$input_username"
        return 0
    fi
    
    if ! id "$input_username" &>/dev/null; then
        error "$(get_message "L'utilisateur n'existe pas" "User does not exist")"
        return 1
    fi
    
    USERNAME="$input_username"
    return 0
}


install_monero_cli() {
    if [ -z "$USERNAME" ]; then
        error "$(get_message "Nom d'utilisateur non défini" "Username not defined")"
        return 1
    fi

    print_header "$(get_message "INSTALLATION DE MONERO" "MONERO INSTALLATION")"
    
    # Création du répertoire d'installation
    mkdir -p ~/monero_install
    cd ~/monero_install || exit
    
    # Définition du nom de fichier
    local MONERO_FILE="monero-linux-x64-v${MONERO_VERSION}.tar.bz2"
    
    info "$(get_message "Téléchargement de Monero..." "Downloading Monero...")"
    if wget --tries=3 "https://downloads.getmonero.org/cli/${MONERO_FILE}"; then
        success "$(get_message "Téléchargement terminé" "Download completed")"
        
        # Vérification de la taille du fichier
        local FILE_SIZE=$(stat -f%z "$MONERO_FILE" 2>/dev/null || stat -c%s "$MONERO_FILE")
        if [ "$FILE_SIZE" -lt 1000000 ]; then  # Si le fichier fait moins de 1MB
            error "$(get_message "Fichier téléchargé incomplet" "Downloaded file is incomplete")"
            rm -f "$MONERO_FILE"
            return 1
        fi
        
        info "$(get_message "Extraction des fichiers..." "Extracting files...")"
        if tar xvjf "$MONERO_FILE"; then
            success "$(get_message "Extraction terminée" "Extraction completed")"
        else
            error "$(get_message "Échec de l'extraction - Tentative de re-téléchargement" "Extraction failed - Trying to download again")"
            rm -f "$MONERO_FILE"
            if wget --tries=3 "https://downloads.getmonero.org/cli/${MONERO_FILE}" && tar xvjf "$MONERO_FILE"; then
                success "$(get_message "Second essai réussi" "Second attempt successful")"
            else
                error "$(get_message "Installation impossible" "Installation impossible")"
                return 1
            fi
        fi
    else
        error "$(get_message "Échec du téléchargement" "Download failed")"
        return 1
    fi

    # Suite de l'installation 
    sudo mkdir -p "/home/$USERNAME/monero"
    sudo cp -r "monero-x86_64-linux-gnu-v${MONERO_VERSION}"/* "/home/$USERNAME/monero/"
    echo "export PATH=\$PATH:/home/$USERNAME/monero" | sudo tee -a "/home/$USERNAME/.bashrc"

    sudo chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/monero"
    sudo chmod -R 755 "/home/$USERNAME/monero"

    sudo mkdir -p "/home/$USERNAME/.bitmonero"
    sudo chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.bitmonero"
    sudo chmod -R 755 "/home/$USERNAME/.bitmonero"

    cd ~ || exit
    rm -rf ~/monero_install

    success "$(get_message "Installation terminée dans /home/$USERNAME/monero" "Installation completed in /home/$USERNAME/monero")"
    return 0
}
install_tor() {
    print_header "$(get_message "INSTALLATION DE TOR" "TOR INSTALLATION")"
    
    # Vérifier si Tor est déjà installé
    if ! command -v tor &> /dev/null; then
        info "$(get_message "Installation de Tor..." "Installing Tor...")"
        if sudo apt update && sudo apt install -y tor; then
            success "$(get_message "Installation de Tor terminée" "Tor installation completed")"
        else
            error "$(get_message "Échec de l'installation de Tor" "Tor installation failed")"
            return 1
        fi
    else
        info "$(get_message "Tor est déjà installé" "Tor is already installed")"
    fi

    # Sauvegarder la configuration originale si elle existe
    if [ -f /etc/tor/torrc ]; then
        sudo cp /etc/tor/torrc /etc/tor/torrc.backup
    fi

    # Écrire la nouvelle configuration
    sudo bash -c 'cat > /etc/tor/torrc << EOL
# Configuration Tor pour Monero
SOCKSPort 9050
ControlPort 9051
HiddenServiceDir /var/lib/tor/ssh/
HiddenServicePort 22 127.0.0.1:22
HiddenServiceDir /var/lib/tor/monero-service/
HiddenServicePort 18081 127.0.0.1:18081
EOL'

    # Créer les répertoires seulement s'ils n'existent pas
    if [ ! -d "/var/lib/tor/monero-service/" ]; then
        sudo mkdir -p /var/lib/tor/monero-service/
        sudo chown -R debian-tor:debian-tor /var/lib/tor/monero-service/
        sudo chmod 700 /var/lib/tor/monero-service/
    fi

    if [ ! -d "/var/lib/tor/ssh/" ]; then
        sudo mkdir -p /var/lib/tor/ssh/
        sudo chown -R debian-tor:debian-tor /var/lib/tor/ssh/
        sudo chmod 700 /var/lib/tor/ssh/
    fi

    info "$(get_message "Redémarrage de Tor..." "Restarting Tor...")"
    sudo systemctl restart tor

    info "$(get_message "Génération de l'adresse onion..." "Generating onion address...")"
    sleep 10

    if [ -f /var/lib/tor/monero-service/hostname ]; then
        ONION_ADDRESS=$(sudo cat /var/lib/tor/monero-service/hostname)
        success "$(get_message "Adresse onion: $ONION_ADDRESS" "Onion address: $ONION_ADDRESS")"
        echo "Monero Onion Address ($(date)): $ONION_ADDRESS" | sudo tee -a "/home/$USERNAME/monero_onion_address.txt"
        sudo chown "$USERNAME:$USERNAME" "/home/$USERNAME/monero_onion_address.txt"
        echo "-------------------->$(get_message "L'adresse TOR est sauvegardée dans le dossier /home" "The TOR address is saved in the folder /home")"
    else
        error "$(get_message "Échec de la génération de l'adresse onion" "Failed to generate onion address")"
    fi

# Gestion de l'adresse SSH
    if [ -f /var/lib/tor/ssh/hostname ]; then
        SSH_ONION_ADDRESS=$(sudo cat /var/lib/tor/ssh/hostname)
        success "$(get_message "Adresse onion SSH: " "SSH onion address: ")$SSH_ONION_ADDRESS"
        echo "SSH Onion Address ($(date)): $SSH_ONION_ADDRESS" | sudo tee -a "/home/$USERNAME/ssh_onion_address.txt"
        sudo chown "$USERNAME:$USERNAME" "/home/$USERNAME/ssh_onion_address.txt"
        echo "-------------------->$(get_message "L'adresse SSH est sauvegardée dans le dossier /home" "The SSH address is saved in the folder /home")"
    else
        error "$(get_message "Échec de la génération de l'adresse onion SSH" "Failed to generate SSH onion address")"
    fi

    read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
}

# Configuration de Monero
configure_monero() {
    if [ -z "$USERNAME" ]; then
        error "$(get_message "Nom d'utilisateur non défini" "Username not defined")"
        return 1
    fi

    print_header "$(get_message "CONFIGURATION DE MONERO" "MONERO CONFIGURATION")"
    
    CONFIG_FILE="/home/$USERNAME/.bitmonero/bitmonero.conf"
    mkdir -p "/home/$USERNAME/.bitmonero"

    # Configuration de base
    cat > "$CONFIG_FILE" << EOL
# Configuration Monero
no-igd=1
no-zmq=1
rpc-bind-ip=0.0.0.0
rpc-bind-port=18081
p2p-bind-port=18080
p2p-bind-ip=0.0.0.0
in-peers=32
out-peers=32
disable-dns-checkpoints=1
confirm-external-bind=1
data-dir=/home/$USERNAME/.bitmonero
EOL

    sudo chown "$USERNAME:$USERNAME" "$CONFIG_FILE"
    sudo chmod 644 "$CONFIG_FILE"
    # S'assurer que l'utilisateur a le contrôle total du dossier
sudo chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.bitmonero"
sudo chmod -R u+rw "/home/$USERNAME/.bitmonero"
# Vérifier si la blockchain est sur un disque externe
if grep -q "data-dir=" "$CONFIG_FILE" | grep -q "/media"; then
    # Si la blockchain est sur un disque externe
    BLOCKCHAIN_PATH=$(grep "data-dir=" "$CONFIG_FILE" | cut -d'=' -f2)
    
    # Créer un lien symbolique si nécessaire
    if [ ! -d "$BLOCKCHAIN_PATH" ]; then
        mkdir -p "$(dirname "$BLOCKCHAIN_PATH")"
        ln -sf "/home/$USERNAME/.bitmonero" "$BLOCKCHAIN_PATH"
    fi
fi
    success "$(get_message "Configuration créée dans $CONFIG_FILE" "Configuration created in $CONFIG_FILE")"
    read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
}

# Configuration des DNS
configure_dns() {
    print_header "$(get_message "CONFIGURATION DNS" "DNS CONFIGURATION")"
    
    info "$(get_message "Configuration des serveurs DNS..." "Configuring DNS servers...")"

    sudo cp /etc/resolv.conf /etc/resolv.conf.backup

    if systemctl is-active --quiet systemd-resolved; then
        sudo systemctl stop systemd-resolved
        sudo systemctl disable systemd-resolved
    fi

    if [ -L /etc/resolv.conf ]; then
        sudo rm /etc/resolv.conf
    fi

    cat << EOL | sudo tee /etc/resolv.conf
# Serveurs DNS pour Monero
nameserver 94.140.14.14
nameserver 94.140.15.15
EOL

    sudo chmod 644 /etc/resolv.conf

    success "$(get_message "Configuration DNS terminée" "DNS configuration completed")"
    info "$(get_message "Backup créé: /etc/resolv.conf.backup" "Backup created: /etc/resolv.conf.backup")"
    
    read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
}

unmount_sdb1() {
    print_header "$(get_message "DÉMONTAGE DU DISQUE" "DISK UNMOUNTING")"
    
    MOUNT_POINT="/media/$USERNAME"
    
    if mount | grep -q "$MOUNT_POINT"; then
        if lsof "$MOUNT_POINT" > /dev/null 2>&1; then
            warning "$(get_message "Fermeture des processus en cours..." "Closing active processes...")"
            lsof "$MOUNT_POINT" | awk 'NR!=1 {print $2}' | xargs -r sudo kill
            sleep 2
        fi
        
        if sudo umount -f "$MOUNT_POINT"; then
            success "$(get_message "Disque démonté avec succès" "Disk unmounted successfully")"
            
            if [ -n "$USERNAME" ]; then
                CONFIG_FILE="/home/$USERNAME/.bitmonero/bitmonero.conf"
                if [ -f "$CONFIG_FILE" ]; then
                    # Supprimer l'ancienne ligne data-dir
                    grep -v "^data-dir=" "$CONFIG_FILE" | sudo tee "$CONFIG_FILE.tmp" > /dev/null
                    # Ajouter la nouvelle ligne data-dir
                    echo "data-dir=/home/$USERNAME/.bitmonero" | sudo tee -a "$CONFIG_FILE.tmp"
                    sudo mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
                    sudo chown "$USERNAME:$USERNAME" "$CONFIG_FILE"
                    sudo chmod 644 "$CONFIG_FILE"
                    # S'assurer que l'utilisateur a le contrôle total du dossier
sudo chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.bitmonero"
sudo chmod -R u+rw "/home/$USERNAME/.bitmonero"
                    
                    success "$(get_message "Configuration Monero mise à jour" "Monero configuration updated")"
                fi
            else
                warning "$(get_message "Impossible de mettre à jour la configuration: utilisateur non défini" "Cannot update configuration: username not defined")"
            fi
        else
            error "$(get_message "Échec du démontage" "Unmounting failed")"
            return 1
        fi
    else
        warning "$(get_message "Le disque n'est pas monté sur $MOUNT_POINT" "Disk is not mounted on $MOUNT_POINT")"
    fi
    read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
}

# Gestion de la blockchain
manage_blockchain() {
    print_header "$(get_message "GESTION DE LA BLOCKCHAIN" "BLOCKCHAIN MANAGEMENT")"
    
    if [ -z "$USERNAME" ]; then
        error "$(get_message "Nom d'utilisateur non défini" "Username not defined")"
        return 1
    fi

    # Définition des chemins
    EXTERNAL_DRIVE="/media/$USERNAME"
    
    BLOCKCHAIN_FOLDER="MoneroBlockchain"
    BLOCKCHAIN_PATH="$EXTERNAL_DRIVE/$BLOCKCHAIN_FOLDER"

    info "$(get_message "Liste des disques disponibles:" "Available disks:")"
    lsblk -nrpo "NAME,SIZE,TYPE,MOUNTPOINT,FSTYPE" | awk '$3=="disk" || $3=="part"'
    
    echo -n "$(print_styled "INFO" "$(get_message "Entrez le nom du disque (ex: sdb1): " "Enter disk name (e.g., sdb1): ")")"
    read -r DEVICE
    
    if [ -z "$DEVICE" ]; then
        error "$(get_message "Aucun disque sélectionné" "No disk selected")"
        return 1
    fi
    
    DEVICE="/dev/$DEVICE"
    
    if [ ! -b "$DEVICE" ]; then
        error "$(get_message "Le périphérique $DEVICE n'existe pas" "Device $DEVICE does not exist")"
        return 1
    fi

           # Démontage du disque s'il est déjà monté
    if mount | grep -q "$DEVICE"; then
        sudo umount "$DEVICE" 2>/dev/null
    fi

    # Création et montage du point de montage
    sudo mkdir -p "$EXTERNAL_DRIVE"
if ! sudo mount -o uid=$(id -u $USERNAME),gid=$(id -g $USERNAME) "$DEVICE" "$EXTERNAL_DRIVE"; then
    error "$(get_message "Échec du montage" "Mount failed")"
    return 1
fi
    
    # Création du dossier blockchain et configuration des permissions
    sudo mkdir -p "$BLOCKCHAIN_PATH"
    

    # Sauvegarde de la configuration actuelle si elle existe
    CONFIG_FILE="/home/$USERNAME/.bitmonero/bitmonero.conf"
    if [ -f "$CONFIG_FILE" ]; then
        sudo cp "$CONFIG_FILE" "${CONFIG_FILE}.backup"
    fi

    # S'assurer que le répertoire de configuration existe
    sudo mkdir -p "$(dirname "$CONFIG_FILE")"

    # Créer une configuration temporaire
    TMP_CONFIG=$(mktemp)
    
    # Écrire la nouvelle configuration
    {
        echo "# Configuration Monero"
        echo "no-igd=1"
        echo "no-zmq=1"
        echo "rpc-bind-ip=0.0.0.0"
        echo "rpc-bind-port=18081"
        echo "p2p-bind-port=18080"
        echo "p2p-bind-ip=0.0.0.0"
        echo "in-peers=32"
        echo "out-peers=32"
        #echo "limit-rate-up=256"
        #echo "limit-rate-down=2048"
        echo "disable-dns-checkpoints=1"
        echo "confirm-external-bind=1"
        echo "data-dir=$BLOCKCHAIN_PATH"
        if [ "$BLOCKCHAIN_TYPE" = "pruned" ]; then
            echo "prune-blockchain=1"
        fi
    } > "$TMP_CONFIG"

    # Vérifier que le fichier temporaire a été créé correctement
    if [ -s "$TMP_CONFIG" ]; then
        # Copier le fichier temporaire vers l'emplacement final
        sudo cp "$TMP_CONFIG" "$CONFIG_FILE"
        rm "$TMP_CONFIG"
        
        # Vérifier que la ligne data-dir est présente
        if ! grep -q "^data-dir=" "$CONFIG_FILE"; then
            echo "data-dir=$BLOCKCHAIN_PATH" | sudo tee -a "$CONFIG_FILE"
        fi
    else
        error "$(get_message "Erreur lors de la création de la configuration" "Error creating configuration")"
        rm -f "$TMP_CONFIG"
        return 1
    fi

    # Configuration des permissions du fichier de configuration
    sudo chown "$USERNAME:$USERNAME" "$CONFIG_FILE"
    sudo chmod 644 "$CONFIG_FILE"
    sudo chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.bitmonero"
    sudo chmod -R u+rw "/home/$USERNAME/.bitmonero"

  # 1er changement  
#if ! grep -q "$DEVICE.*$EXTERNAL_DRIVE" /etc/fstab; then
 #   DEVICE_UUID=$(sudo blkid -s UUID -o value "$DEVICE")
  #  echo "UUID=$DEVICE_UUID $EXTERNAL_DRIVE auto defaults,uid=$(id -u $USERNAME),gid=$(id -g $USERNAME),nofail 0 0" | sudo tee -a /etc/fstab
   # success "$(get_message "Configuration du montage automatique ajoutée" "Automatic mount configuration added")"
#fi

# Obtenir l'UUID du disque
DEVICE_UUID=$(sudo blkid -s UUID -o value "$DEVICE")
if [ -z "$DEVICE_UUID" ]; then
    error "$(get_message "Impossible d'obtenir l'UUID du disque" "Unable to get disk UUID")"
    return 1
fi

# Sauvegarder l'état de montage original
MOUNTPOINT_BEFORE=$(findmnt -n -o TARGET -S UUID="$DEVICE_UUID" 2>/dev/null || echo "")
if [ -n "$MOUNTPOINT_BEFORE" ] && [ "$MOUNTPOINT_BEFORE" != "$EXTERNAL_DRIVE" ]; then
    info "$(get_message "Le disque est actuellement monté sur $MOUNTPOINT_BEFORE" "Disk is currently mounted on $MOUNTPOINT_BEFORE")"
fi

# Supprimer les entrées existantes pour cet UUID dans fstab
if grep -q "UUID=$DEVICE_UUID" /etc/fstab; then
    info "$(get_message "Suppression des entrées existantes pour UUID=$DEVICE_UUID" "Removing existing entries for UUID=$DEVICE_UUID")"
    sudo sed -i "/UUID=$DEVICE_UUID/d" /etc/fstab
fi

# Ajouter une nouvelle entrée fstab spéciale pour EasyNode
USER_ID=$(id -u "$USERNAME")
GROUP_ID=$(id -g "$USERNAME")
# Cette entrée permet à la fois le montage spécifique pour EasyNode et le montage automatique normal
echo "# Entrée pour EasyNode - Ne pas modifier manuellement" | sudo tee -a /etc/fstab > /dev/null
echo "UUID=$DEVICE_UUID $EXTERNAL_DRIVE auto defaults,users,uid=$USER_ID,gid=$GROUP_ID,umask=022,nofail,x-gvfs-show 0 0" | sudo tee -a /etc/fstab > /dev/null
success "$(get_message "Configuration du montage automatique ajoutée/mise à jour" "Automatic mount configuration added/updated")"

# Recharger systemd pour prendre en compte les modifications
info "$(get_message "Rechargement de systemd..." "Reloading systemd...")"
sudo systemctl daemon-reload

# S'assurer que le disque est monté
if ! mountpoint -q "$EXTERNAL_DRIVE"; then
    info "$(get_message "Montage du disque..." "Mounting disk...")"
    sudo mount -a
    
    if ! mountpoint -q "$EXTERNAL_DRIVE"; then
        warning "$(get_message "Le montage automatique a échoué, tentative de montage direct..." "Automatic mount failed, trying direct mount...")"
        sudo mount -U "$DEVICE_UUID" "$EXTERNAL_DRIVE"
    fi
fi




    success "$(get_message "Blockchain configurée dans: $BLOCKCHAIN_PATH" "Blockchain configured in: $BLOCKCHAIN_PATH")"
    info "$(get_message "Le disque sera monté automatiquement au démarrage" "The disk will be automatically mounted at boot")"
    read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
}
apply_ip_bans() {
    local MONEROD_PATH="$1"
    local BAN_LIST_FILE="/home/$USERNAME/.bitmonero/ban_list.txt"
    
    info "$(get_message "Application des bans IP..." "Applying IP bans...")"
    
    # Attendre que le service RPC soit disponible
    for i in {1..30}; do
        if nc -z localhost 18081; then
            success "$(get_message "Service RPC disponible" "RPC service available")"
            break
        fi
        info "$(get_message "Attente du service RPC... ($i/30)" "Waiting for RPC service... ($i/30)")"
        sleep 2
    done

    # Vérifier si le fichier existe
    if [ ! -f "$BAN_LIST_FILE" ]; then
        error "$(get_message "Fichier de bans non trouvé" "Ban list file not found")"
        return 1
    fi

    # Lire et appliquer les bans
    while IFS=' ' read -r line || [ -n "$line" ]; do
        # Ignorer les lignes vides et les commentaires
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Extraire IP et durée
        read -r ip duration <<< "$line"
        
        if [ -n "$ip" ] && [ -n "$duration" ]; then
            "$MONEROD_PATH" ban "$ip" "$duration" --rpc-bind-port 18081
            info "$(get_message "Ban appliqué: $ip" "Ban applied: $ip")"
        fi
    done < "$BAN_LIST_FILE"

    success "$(get_message "Application des bans terminée" "Ban application completed")"
}
#demarrage de la blockchain

# Fonction modifiée pour gérer CTRL+C et revenir au menu
start_blockchain() {
    if [ -z "$USERNAME" ]; then
        error "$(get_message "Nom d'utilisateur non défini" "Username not defined")"
        return 1
    fi

    print_header "$(get_message "DÉMARRAGE DE LA BLOCKCHAIN" "STARTING BLOCKCHAIN")"
    
    # Sélection du type de blockchain déplacée ici
    print_styled "PRIMARY" "$(get_message "Sélectionnez le type de blockchain:" "Select blockchain type:")"
    print_styled "PRIMARY" "1) $(get_message "Complète 220 Go" "Complete 220 Go")"
    print_styled "PRIMARY" "2) $(get_message "Prune 90 Go" "Pruned 90 Go")"
    echo -n "$(print_styled "INFO" "$(get_message "Choix (1-2): " "Choice (1-2): ")")"
    read -r bc_choice
    
    case $bc_choice in
        1) BLOCKCHAIN_TYPE="complete" ;;
        2) BLOCKCHAIN_TYPE="pruned" ;;
        *) 
            error "$(get_message "Choix invalide" "Invalid choice")"
            return 1 ;;
    esac
    
    CONFIG_FILE="/home/$USERNAME/.bitmonero/bitmonero.conf"
    DEFAULT_DATA_DIR="/home/$USERNAME/.bitmonero"
    
    # Mise à jour du fichier de configuration avec le choix du type de blockchain
    if [ -f "$CONFIG_FILE" ]; then
        # Suppression de l'ancienne ligne prune-blockchain si elle existe
        sudo sed -i '/^prune-blockchain=/d' "$CONFIG_FILE"
        
        # Ajout de la ligne prune-blockchain si nécessaire
        if [ "$BLOCKCHAIN_TYPE" = "pruned" ]; then
            echo "prune-blockchain=1" | sudo tee -a "$CONFIG_FILE" > /dev/null
        fi
        
        BLOCKCHAIN_LOCATION=$(grep "^data-dir=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
    fi

    # Si aucun emplacement n'est trouvé dans le fichier de config, on utilise l'emplacement par défaut
    if [ -z "$BLOCKCHAIN_LOCATION" ]; then
        BLOCKCHAIN_LOCATION="$DEFAULT_DATA_DIR"
    fi

    info "$(get_message "Emplacement de la blockchain: $BLOCKCHAIN_LOCATION" "Blockchain location: $BLOCKCHAIN_LOCATION")"
    
    # Téléchargement de la liste des IP bannis
    download_ban_list
    
    # Vérification du montage du disque externe si nécessaire
    if [ -n "$BLOCKCHAIN_LOCATION" ] && [[ "$BLOCKCHAIN_LOCATION" == "/media/$USERNAME"* ]]; then
        DEVICE=$(mount | grep "/media/$USERNAME" | awk '{print $1}')
        if [ -z "$DEVICE" ]; then
            error "$(get_message "Le disque externe n'est pas monté" "External disk is not mounted")"
            return 1
        fi
        info "$(get_message "Disque externe monté: $DEVICE" "External disk mounted: $DEVICE")"
    fi

    print_styled "PRIMARY" "$(get_message "Démarrer la blockchain MONERO ?" "Start MONERO blockchain?")"
    print_styled "PRIMARY" "1) $(get_message "Avec blocage IP" "With IP blocking")"
    print_styled "PRIMARY" "2) $(get_message "Sans blocage IP" "Without IP blocking")"
    print_styled "PRIMARY" "3) $(get_message "Annuler" "Cancel")"
    echo -n "$(print_styled "INFO" "$(get_message "Choix (1-3): " "Choice (1-3): ")")"
    read -r START_CHOICE

    # Vérification des permissions avant le démarrage
    if [ -n "$BLOCKCHAIN_LOCATION" ] && [ ! -w "$BLOCKCHAIN_LOCATION" ]; then
        error "$(get_message "Permissions insuffisantes sur $BLOCKCHAIN_LOCATION" "Insufficient permissions on $BLOCKCHAIN_LOCATION")"
        return 1
    fi

    MONEROD_PATH="/home/$USERNAME/monero/monerod"
    if [ ! -x "$MONEROD_PATH" ]; then
        error "$(get_message "monerod n'est pas trouvé ou n'est pas exécutable" "monerod not found or not executable")"
        return 1
    fi

    case $START_CHOICE in
        1)
            # Variable pour le contrôle d'arrêt
            STOP_MONEROD=0
            
            # Sauvegarde du gestionnaire SIGINT original
            trap_original=$(trap -p SIGINT)
            
            # Fonction pour nettoyer et restaurer l'état original
            cleanup() {
                # Restauration du gestionnaire original
                if [ -n "$trap_original" ]; then
                    eval "$trap_original"
                else
                    trap - SIGINT
                fi
                
                # Arrêt de monerod si en cours d'exécution
                if [ -n "$MONEROD_PID" ] && kill -0 $MONEROD_PID 2>/dev/null; then
                    info "$(get_message "Arrêt de monerod..." "Stopping monerod...")"
                    kill $MONEROD_PID 2>/dev/null
                    wait $MONEROD_PID 2>/dev/null
                fi
                
                success "$(get_message "Blockchain arrêtée" "Blockchain stopped")"
            }
            
            # Gestionnaire pour SIGINT (CTRL+C)
            handle_sigint() {
                echo
                info "$(get_message "CTRL+C détecté, arrêt de la blockchain..." "CTRL+C detected, stopping blockchain...")"
                STOP_MONEROD=1
                
                # Envoi d'un SIGINT à monerod
                if [ -n "$MONEROD_PID" ] && kill -0 $MONEROD_PID 2>/dev/null; then
                    kill -SIGINT $MONEROD_PID 2>/dev/null
                fi
                
                # Retourner au script sans sortir
                return 0
            }
            
            # Installation du gestionnaire SIGINT
            trap handle_sigint SIGINT
            
            # Corriger les permissions avant de démarrer
if [ -n "$BLOCKCHAIN_LOCATION" ]; then
    # Corriger les permissions du dossier de données
    if [ -d "$BLOCKCHAIN_LOCATION" ]; then
        sudo chown -R "$USERNAME:$USERNAME" "$BLOCKCHAIN_LOCATION" 2>/dev/null || true
        sudo chmod -R u+rw "$BLOCKCHAIN_LOCATION" 2>/dev/null || true
    fi
    
    # Corriger les permissions du dossier .bitmonero
    sudo chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.bitmonero" 2>/dev/null || true
    sudo chmod -R u+rw "/home/$USERNAME/.bitmonero" 2>/dev/null || true
fi
            
            # Fonction de monitoring pour Ubuntu
monitor_peers() {
    sleep 15  # Attendre que monerod démarre
    
    # Définir les couleurs
    GREEN='\033[0;32m'
    BLUE='\033[0;34m'
    RESET='\033[0m'
    
    while pgrep -f "monerod" > /dev/null; do
        # Obtenir les infos via RPC
        PEER_INFO=$(curl -s -X POST http://localhost:18081/json_rpc \
            -H "Content-Type: application/json" \
            -d '{"jsonrpc":"2.0","id":"0","method":"get_info"}' 2>/dev/null)
        
        if [ $? -eq 0 ] && echo "$PEER_INFO" | grep -q '"result"'; then
            IN_PEERS=$(echo "$PEER_INFO" | sed -n 's/.*"incoming_connections_count":\s*\([0-9]*\).*/\1/p')
            OUT_PEERS=$(echo "$PEER_INFO" | sed -n 's/.*"outgoing_connections_count":\s*\([0-9]*\).*/\1/p')
            
            # Affichage simplifié pour Ubuntu
            echo -ne "\r${GREEN}IN-PEERS: ${IN_PEERS:-0}${RESET} | ${GREEN}OUT-PEERS: ${OUT_PEERS:-0}${RESET}                    "
        fi
        
        sleep 15  # Actualiser toutes les 15 secondes
    done
}
            # APPEL de la fonction (après définition)
monitor_peers &
MONITOR_PID=$!
            
            # Démarrer monerod dans un processus en arrière-plan
            if [ -n "$BLOCKCHAIN_LOCATION" ]; then
                info "$(get_message "Démarrage de la blockchain avec le fichier de configuration" "Starting blockchain with config file")"
                "$MONEROD_PATH" --config-file="$CONFIG_FILE" --non-interactive &
                MONEROD_PID=$!
            else
                info "$(get_message "Démarrage de la blockchain avec le dossier par défaut" "Starting blockchain with default folder")"
                "$MONEROD_PATH" --data-dir="$DEFAULT_DATA_DIR" --non-interactive &
                MONEROD_PID=$!
            fi
            
            # Attendre que le service RPC soit disponible
            info "$(get_message "Attente du démarrage du service RPC..." "Waiting for RPC service to start...")"
            for i in {1..60}; do
                if [ $STOP_MONEROD -eq 1 ]; then
                    break
                fi
                
                if nc -z localhost 18081; then
                    success "$(get_message "Service RPC disponible" "RPC service available")"
                    break
                fi
                
                echo -n "."
                sleep 2
                
                if [ $i -eq 60 ]; then
                    error "$(get_message "Timeout en attendant le service RPC" "Timeout waiting for RPC service")"
                fi
            done
            
            # Si l'arrêt n'a pas été demandé, appliquer les bans
            if [ $STOP_MONEROD -eq 0 ]; then
                # Une fois que le service est disponible, appliquer les bans
                info "$(get_message "Application des bans IP..." "Applying IP bans...")"
                sleep 5  # Attendre un peu plus pour s'assurer que le service est prêt
                
                # Définir la durée de ban à 3 mois (en secondes)
                local BAN_DURATION=7776000  # 3 mois en secondes (30 jours * 3 * 24 heures * 60 minutes * 60 secondes)
                
                # Appliquer les bans
                BAN_LIST_FILE="/home/$USERNAME/.bitmonero/ban_list.txt"
                if [ -f "$BAN_LIST_FILE" ]; then
                    # Compter le nombre total de bans à appliquer
                    local total_bans=$(grep -v "^#" "$BAN_LIST_FILE" | grep -v "^$" | wc -l)
                    info "$(get_message "Nombre total d'adresses IP à bannir: $total_bans" "Total number of IP addresses to ban: $total_bans")"
                    info "$(get_message "Durée des bans: 3 mois" "Ban duration: 3 months")"
                    
                    # Lire et appliquer les bans
                   local counter=0
local success_count=0

while IFS=' ' read -r line || [ -n "$line" ]; do
    # Vérifier si l'arrêt a été demandé
    if [ $STOP_MONEROD -eq 1 ]; then
        break
    fi
    
    # Ignorer les lignes vides et les commentaires
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    
    # Extraire IP (ignorer la durée spécifiée dans le fichier)
    read -r ip duration_ignored <<< "$line"
    
    if [ -n "$ip" ]; then
        counter=$((counter + 1))
        
        # Afficher chaque IP bannie avec compteur de progression
        info "$(get_message "Ban IP $counter/$total_bans: $ip" "Banning IP $counter/$total_bans: $ip")"
        
        # Appliquer le ban avec une durée de 3 mois
        "$MONEROD_PATH" ban "$ip" "$BAN_DURATION" --rpc-bind-port 18081 &>/dev/null
        if [ $? -eq 0 ]; then
            success_count=$((success_count + 1))
        else
            warning "$(get_message "Échec du ban pour l'IP: $ip" "Ban failed for IP: $ip")"
        fi
    fi
done < "$BAN_LIST_FILE"
                    
                    success "$(get_message "Bans appliqués: $success_count/$total_bans" "Bans applied: $success_count/$total_bans")"
                    
                    # Vérifier l'état des bans
                    info "$(get_message "Vérification de l'état des bans..." "Checking ban status...")"
                    ban_status=$("$MONEROD_PATH" bans --rpc-bind-port 18081 2>/dev/null)
                    ban_count=$(echo "$ban_status" | grep -c "subnet\|IP")
                    success "$(get_message "Nombre total de bans actifs: $ban_count" "Total active bans: $ban_count")"
                    
                    # Afficher les 5 premiers bans pour confirmation
                    echo "$ban_status" | head -n 5
                else
                    warning "$(get_message "Fichier de bans non trouvé: $BAN_LIST_FILE" "Ban list file not found: $BAN_LIST_FILE")"
                fi
            fi
            
            # Message pour informer l'utilisateur comment arrêter
            print_styled "PRIMARY" "$(get_message "Patientez..." "Wait..")"
            
            # Attendre que monerod se termine ou que CTRL+C soit pressé
            while [ $STOP_MONEROD -eq 0 ]; do
                if ! kill -0 $MONEROD_PID 2>/dev/null; then
                    info "$(get_message "Le processus monerod s'est terminé" "Monerod process has terminated")"
                    STOP_MONEROD=1
                    break
                fi
                sleep 1
            done
             if [ -n "$MONITOR_PID" ]; then
                kill $MONITOR_PID 2>/dev/null
            fi
            # Nettoyage
            cleanup
            ;;
        2)
            # Démarrer sans les bans IP
            # Variable pour le contrôle d'arrêt
            STOP_MONEROD=0
            
            # Sauvegarde du gestionnaire SIGINT original
            trap_original=$(trap -p SIGINT)
            
            # Fonction pour nettoyer et restaurer l'état original
            cleanup() {
                # Restauration du gestionnaire original
                if [ -n "$trap_original" ]; then
                    eval "$trap_original"
                else
                    trap - SIGINT
                fi
                
                # Arrêt de monerod si en cours d'exécution
                if [ -n "$MONEROD_PID" ] && kill -0 $MONEROD_PID 2>/dev/null; then
                    info "$(get_message "Arrêt de monerod..." "Stopping monerod...")"
                    kill $MONEROD_PID 2>/dev/null
                    wait $MONEROD_PID 2>/dev/null
                fi
                
                success "$(get_message "Blockchain arrêtée" "Blockchain stopped")"
            }
            
            # Gestionnaire pour SIGINT (CTRL+C)
            handle_sigint() {
                echo
                info "$(get_message "CTRL+C détecté, arrêt de la blockchain..." "CTRL+C detected, stopping blockchain...")"
                STOP_MONEROD=1
                
                # Envoi d'un SIGINT à monerod
                if [ -n "$MONEROD_PID" ] && kill -0 $MONEROD_PID 2>/dev/null; then
                    kill -SIGINT $MONEROD_PID 2>/dev/null
                fi
                
                # Retourner au script sans sortir
                return 0
            }
            
            # Installation du gestionnaire SIGINT
            trap handle_sigint SIGINT
            
            # Corriger les permissions avant de démarrer
if [ -n "$BLOCKCHAIN_LOCATION" ]; then
    # Corriger les permissions du dossier de données
    if [ -d "$BLOCKCHAIN_LOCATION" ]; then
        sudo chown -R "$USERNAME:$USERNAME" "$BLOCKCHAIN_LOCATION" 2>/dev/null || true
        sudo chmod -R u+rw "$BLOCKCHAIN_LOCATION" 2>/dev/null || true
    fi
    
    # Corriger les permissions du dossier .bitmonero
    sudo chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.bitmonero" 2>/dev/null || true
    sudo chmod -R u+rw "/home/$USERNAME/.bitmonero" 2>/dev/null || true
fi
                      # Fonction de monitoring pour Ubuntu
monitor_peers() {
    sleep 15  # Attendre que monerod démarre
    
    # Définir les couleurs
    GREEN='\033[0;32m'
    BLUE='\033[0;34m'
    RESET='\033[0m'
    
    while pgrep -f "monerod" > /dev/null; do
        # Obtenir les infos via RPC
        PEER_INFO=$(curl -s -X POST http://localhost:18081/json_rpc \
            -H "Content-Type: application/json" \
            -d '{"jsonrpc":"2.0","id":"0","method":"get_info"}' 2>/dev/null)
        
        if [ $? -eq 0 ] && echo "$PEER_INFO" | grep -q '"result"'; then
            IN_PEERS=$(echo "$PEER_INFO" | sed -n 's/.*"incoming_connections_count":\s*\([0-9]*\).*/\1/p')
            OUT_PEERS=$(echo "$PEER_INFO" | sed -n 's/.*"outgoing_connections_count":\s*\([0-9]*\).*/\1/p')
            
            # Affichage simplifié pour Ubuntu
            echo -ne "\r${GREEN}IN-PEERS: ${IN_PEERS:-0}${RESET} | ${GREEN}OUT-PEERS: ${OUT_PEERS:-0}${RESET}                    "
        fi
        
        sleep 15  # Actualiser toutes les 15 secondes
    done
}
            # APPEL de la fonction (après définition)
monitor_peers &
MONITOR_PID=$!
            
            
            # Démarrer monerod dans un processus en arrière-plan
            if [ -n "$BLOCKCHAIN_LOCATION" ]; then
                info "$(get_message "Démarrage de la blockchain avec le fichier de configuration" "Starting blockchain with config file")"
                "$MONEROD_PATH" --config-file="$CONFIG_FILE" --non-interactive &
                MONEROD_PID=$!
            else
                info "$(get_message "Démarrage de la blockchain avec le dossier par défaut" "Starting blockchain with default folder")"
                "$MONEROD_PATH" --data-dir="$DEFAULT_DATA_DIR" --non-interactive &
                MONEROD_PID=$!
            fi
            
            # Message pour informer l'utilisateur comment arrêter
            print_styled "PRIMARY" "$(get_message "Appuyez sur CTRL+C pour arrêter la blockchain et revenir au menu" "Press CTRL+C to stop the blockchain and return to the menu")"
            
            # Attendre que monerod se termine ou que CTRL+C soit pressé
            while [ $STOP_MONEROD -eq 0 ]; do
                if ! kill -0 $MONEROD_PID 2>/dev/null; then
                    info "$(get_message "Le processus monerod s'est terminé" "Monerod process has terminated")"
                    STOP_MONEROD=1
                    break
                fi
                sleep 1
            done
             if [ -n "$MONITOR_PID" ]; then
                kill $MONITOR_PID 2>/dev/null
            fi
            # Nettoyage
            cleanup
            ;;
        3|*)
            info "$(get_message "Démarrage annulé" "Startup cancelled")"
            return 1
            ;;
    esac
    
    return 0
}

# Fonction pour télécharger la liste des IP bannis
download_ban_list() {
    local BAN_LIST_FILE="/home/$USERNAME/.bitmonero/ban_list.txt"
    local BAN_LIST_URL="https://raw.githubusercontent.com/Boog900/monero-ban-list/main/ban_list.txt"
    
    info "$(get_message "Téléchargement de la liste des IP bannis..." "Downloading IP ban list...")"
    
    # Créer le répertoire si nécessaire
    mkdir -p "/home/$USERNAME/.bitmonero"
    
    # Télécharger la liste des bans
    if wget -q -O "$BAN_LIST_FILE" "$BAN_LIST_URL"; then
        sudo chown "$USERNAME:$USERNAME" "$BAN_LIST_FILE"
        sudo chmod 644 "$BAN_LIST_FILE"
        success "$(get_message "Liste des IP bannis téléchargée avec succès" "IP ban list downloaded successfully")"
    else
        error "$(get_message "Échec du téléchargement de la liste des IP bannis" "Failed to download IP ban list")"
        
        # Créer un fichier vide si le téléchargement échoue
        if [ ! -f "$BAN_LIST_FILE" ]; then
            touch "$BAN_LIST_FILE"
            sudo chown "$USERNAME:$USERNAME" "$BAN_LIST_FILE"
            sudo chmod 644 "$BAN_LIST_FILE"
        fi
    fi
}
# Affichage des notes et informations
show_notes() {
          clear
                setup_terminal
                echo -e "\n\n\n\n\n\n\n\n"  # Espace pour la bannière 
                

                print_header "$(get_message "NOTES" "READ")"
                
                print_styled "MONERO" "$(get_message "- Pour arrêter la blockchain : CTRL + C" "- To stop the blockchain: CTRL + C")"
                echo
                print_styled "MONERO" "$(get_message "- Votre nom d'utilisateur est: ${COLORS[SUCCESS]}$SUDO_USER${COLORS[INFO]}" "- Your username is: ${COLORS[SUCCESS]}$SUDO_USER${COLORS[INFO]}")"
                echo
                #print_styled "INFO" "$(get_message "- Votre nom d'utilisateur est: $USERNAME" "- Your username is: $USERNAME")"
                #print_styled "INFO" "$(get_message "- Le nom utilisateur se trouve apres /home/.." "- username is after /home/..")"
                print_styled "MONERO" "$(get_message "- Vérification de l'adresse IP Tor..." "- Checking Tor IP address...")"
    TOR_IP=$(torsocks curl -s https://check.torproject.org/api/ip 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$TOR_IP" ]; then
        print_styled "SUCCESS" "$(get_message "- Adresse IP TOR: ${COLORS[SUCCESS]}$TOR_IP${COLORS[SUCCESS]}" "- TOR IP address: ${COLORS[SUCCESS]}$TOR_IP${COLORS[SUCCESS]}")"
    else
        print_styled "ERROR" "$(get_message "- Impossible de récupérer l'adresse IP Tor" "- Unable to retrieve Tor IP address")"
    fi
    echo
                print_styled "PRIMARY" "$(get_message "- Configuration réseau requise :" "- Required network configuration:")"
    print_styled "PRIMARY" "$(get_message "⚠️ REDIRIGER le port 22 et 18080 de votre Box internet" "⚠️ Open port 22 and 18080 of your internet router")"
    print_styled "PRIMARY" "$(get_message "  vers l'IP de votre PC." "  to your PC's IP address.")"
    print_styled "MONERO" "$(get_message "  https://github.com/kerlannXmr/EasyMonerod/issues/10" "  https://github.com/kerlannXmr/EasyMonerod/issues/10")"
                echo
    print_styled "MONERO" "$(get_message "- Installer MONERO GUI pour la gestion du wallet" "- Install MONERO GUI for wallet management")"
                print_styled "MONERO" "$(get_message "  MONERO GUI se synchronisera sur ce noeud" "  MONERO GUI will synch on this node")"
                
                print_styled "MONERO" "$(get_message "  https://www.getmonero.org/downloads/" "  https://www.getmonero.org/downloads/")"
                echo
                print_styled "MONERO" "\e]8;;https://mega.nz/file/gjNWgL5B#itd6yCJJk_-1QbP2NbGWIm5DI1CC_MbTr8L6TeDqESI\e\\  PDF Documentations point 5 (CTRL+click)\e]8;;\e\\"
                echo
    
    echo
    print_styled "PRIMARY" "$(get_message "-🙏 Gacieux Dons MONERO(Xmr) pour le dur labeur: " "-🙏 Send MONERO(Xmr) donation for hard work")" 
    print_styled "PRIMARY" "$(get_message "    avec 'cake wallet' à:    kerlann.xmr" "    with 'cake wallet' to:   kerlann.xmr")"
    echo
    print_styled "MONERO" "$(get_message "- Contact:  easynode@kerlann.org" "- Contact:  easynode@kerlann.org")"
    echo
    print_styled "MONERO" "$(get_message "- Code source:" "- Source Code:")"
    print_styled "MONERO" "$(get_message "  https://github.com/kerlannXmr/easymonerod" "  https://github.com/kerlannXmr/easymonerod")"
                
                read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..❤️." "Press Enter to continue..❤️.")")"
}
# Affichage des scripts disponibles
show_scripts() {
       clear
       setup_terminal
       echo -e "\n\n\n\n\n\n"  # Espace pour la bannière
       print_header "$(get_message "INFOS" "FEATURES")"
  
  print_styled "MONERO" "1) $(get_message "Mise à jour système et installation des paquets" "System update and package installation")"
    print_styled "PRIMARY" "   $(get_message "- Configuration du firewall activé avec ouverture des ports :" "- Firewall configuration Actived with ports opening:")"
    echo -e "${COLORS[GRIS]}    $(get_message "-Ports system: 22(SSH), 80(HTTP), 443(HTTPS), 9050(Tor), 4200(SHELL IN BOX), 4444(i2p-http), 4447(i2p-socks), 53317(localsend)" "-System ports: 22(SSH), 80(HTTP), 443(HTTPS), 9050(Tor), 4200(SHELL IN BOX), 4444(i2p-http), 4447(i2p-socks), 53317(localsend)")${COLORS[RESET]}"
    echo -e "${COLORS[GRIS]}    $(get_message "-Ports Monero: 18080(P2P), 18081(Public), 18083(ZMQ), 18084(Tor), 18085(I2P), 18086(LWS), 18081(RPC)" "-Monero ports: 18080(P2P), 18081(Public), 18083(ZMQ), 18084(Tor), 18085(I2P), 18086(LWS), 18081(RPC)")${COLORS[RESET]}"
    echo
    print_styled "MONERO" "2) $(get_message "Installation de Monero CLI" "Monero CLI Installation")"
    print_styled "PRIMARY" "   $(get_message "- Installation des fichiers Monero" "- Installing Monero files")"
    print_styled "PRIMARY" "   $(get_message "- Configuration des permissions" "- Setting up permissions")"
    echo
    print_styled "MONERO" "3) $(get_message "Installation et configuration de TOR" "TOR Installation and configuration")"
           
    if [ -f /var/lib/tor/monero-service/hostname ]; then
    ONION_ADDRESS=$(sudo cat /var/lib/tor/monero-service/hostname)
    echo -e "${COLORS[SUCCESS]}    -TOR Onion: $ONION_ADDRESS${COLORS[RESET]}"
fi
   print_styled "SUCCESS" "     PORT RPC: 18081"
   if [ -f /var/lib/tor/ssh/hostname ]; then
    SSH_ONION_ADDRESS=$(sudo cat /var/lib/tor/ssh/hostname)
    echo -e "${COLORS[SUCCESS]}    -SSH Onion: $SSH_ONION_ADDRESS${COLORS[RESET]}"
fi
   print_styled "SUCCESS" "     PORT SSH: 22"
   print_styled "WARNING" "   $(get_message " Les adresses Tor sont créées uniquement lors de votre installation" "  Tor addresses are only created during installation")"
    echo
    print_styled "MONERO" "4) $(get_message "Configuration de bitmonero.conf" "bitmonero.conf configuration")"
    print_styled "PRIMARY" "   $(get_message "- Configuration du fichier de démarrage" "- Configuring startup file")"
    print_styled "PRIMARY" "   $(get_message "- Configuration des ports" "- Setting up ports")"
    print_styled "SUCCESS" "$(get_message "    -rpc-bind-port=18081" "     rpc-bind-port=18081")"
    print_styled "PRIMARY" "   $(get_message "- Configuration des chemins" "- Setting up paths")"
    echo
    print_styled "MONERO" "5) $(get_message "Configuration DNS Anonyme" "Anonymous DNS Configuration")"
    print_styled "PRIMARY" "   $(get_message "- Installation des DNS sécurisés" "- Installing secure DNS")"
    print_styled "PRIMARY" "   $(get_message "- Configuration des serveurs DNS" "- Configuring DNS servers")"
    echo
    print_styled "MONERO" "6)$(get_message " Démarrage Blockchain et Bloquage 'IP Bans list':" "Start & Block 'IP bans list':")"
    print_styled "PRIMARY" "   $(get_message "- https://github.com/monero-project/meta/issues/1124" "- https://github.com/monero-project/meta/issues/1124")"
    print_styled "PRIMARY" "   $(get_message "- https://github.com/Boog900/monero-ban-list/blob/main/ban_list.txt" "- https://github.com/Boog900/monero-ban-list/blob/main/ban_list.txt")"
    echo
    print_styled "WARNING" "$(get_message " ⚠️  Configurer votre router/Box internet pour REDIRIGER le port 22 et 18080" " ⚠️   Configure your router/internet box to REDIRECT port 22 and 18080")"
   print_styled "WARNING" "$(get_message "    vers l'ADRESSE IP de votre PC" "    to your PC's IP ADDRESS")"
   print_styled "PRIMARY" "$(get_message "- https://github.com/kerlannXmr/EasyMonerod/issues/10" "- https://github.com/kerlannXmr/EasyMonerod/issues/10")"
                echo

                read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
}
# Fonction d'animation pour la fin du programme

monero_animation() {
    clear
    
    # ASCII Art pour MONERO - en enlevant les espaces au début de chaque ligne
    local monero_logo="
███    ███  ██████  ███    ██ ███████ ██████   ██████  
████  ████ ██    ██ ████   ██ ██      ██   ██ ██    ██ 
██ ████ ██ ██    ██ ██ ██  ██ █████   ██████  ██    ██ 
██  ██  ██ ██    ██ ██  ██ ██ ██      ██   ██ ██    ██ 
██      ██  ██████  ██   ████ ███████ ██   ██  ██████  
"
    
    # Ligne décorative de même largeur que le logo
    local decoration_line="══════════════════════════════════════════════════════════"
    
    # Textes à afficher
    local message1="$(get_message "TRANSFERTS ANONYMES" "ANONYMOUS TRANSACTIONS")"
    local message2="$(get_message "PRIVACY MATTERS!" "PRIVACY MATTERS!")"
    
    # Pour centrer l'animation
    local terminal_width=$(tput cols)
    local terminal_height=$(tput lines)
    local logo_width=60
    local center_x=$(( (terminal_width - logo_width) / 2 ))
    local center_y=10
    
    if [ $center_x -lt 0 ]; then
        center_x=0
    fi
    
    # Animation - alterne entre blanc et orange
    for ((i=0; i<12; i++)); do
        # Effacer l'écran à chaque frame
        clear
        
        # Choisir la couleur en alternance (Blanc puis Orange Monero)
        if ((i % 2 == 0)); then
            color="${COLORS[PRIMARY]}"  # Blanc
        else
            color="${COLORS[MONERO]}"   # Orange Monero
        fi
        
        # Afficher le logo MONERO avec la couleur actuelle
        tput cup $center_y $center_x
        echo -e "$color$monero_logo${COLORS[RESET]}"
        
        # Ajouter une ligne décorative exactement sous le logo MONERO (même position x)
        local line_y=$((center_y + 6))
        tput cup $line_y $center_x
        echo -e "$color$decoration_line${COLORS[RESET]}"
        
        # Afficher les messages qui alternent (en dessous de la ligne)
        local msg_y=$((center_y + 8))
        tput cup $msg_y $((center_x + 10))
        
        if ((i % 2 == 0)); then
            echo -e "${COLORS[SUCCESS]}$message1${COLORS[RESET]}"
        else
            echo -e "${COLORS[WARNING]}$message2${COLORS[RESET]}"
        fi
        
        # Petite pause entre chaque frame
        sleep 0.4
    done
}

# Fonction alternative utilisant un autre style de texte
monero_animation() {
    clear

    # Logo M dans un cercle en ASCII art
    local logo_frame1="
      ████████████      
    ██            ██    
   ██   ██    ██   ██   
  ██    ███  ███    ██  
  ██    ██ ██ ██    ██  
  ██    ██    ██    ██  
  ██    ██    ██    ██  
   ██   ██    ██   ██   
    ██            ██    
      ████████████      
"

    local logo_frame2="
      ************      
    **            **    
   **   **    **   **   
  **    ***  ***    **  
  **    ** ** **    **  
  **    **    **    **  
  **    **    **    **  
   **   **    **   **   
    **            **    
      ************      
"

    # Pour centrer horizontalement l'animation, mais la placer en haut
    local terminal_width=$(tput cols)
    local logo_width=24
    local center_x=$(( (terminal_width - logo_width) / 2 ))
    # Positionnement en haut avec un petit décalage de 3 lignes depuis le haut
    local top_y=3
    
    if [ $center_x -lt 0 ]; then
        center_x=0
    fi
    
    # Animation - alterne entre différentes couleurs et styles
    for ((i=0; i<8; i++)); do
        # Effacer l'écran à chaque frame
        clear
        
        # Choisir la couleur et le style
        if ((i % 2 == 0)); then
            # Frame 1 : Logo avec blocks
            logo="${logo_frame1}"
            color="${COLORS[MONERO]}"  # Orange Monero
        else
            # Frame 2 : Logo avec astérisques
            logo="${logo_frame2}"
            color="${COLORS[PRIMARY]}"  # Blanc
        fi
        
        # Afficher le logo avec la couleur actuelle
        tput cup $top_y $center_x
        echo -e "$color$logo${COLORS[RESET]}"
        
        # Pause entre frames
        sleep 0.3
    done
}

show_menu() {
    while true; do
        setup_terminal
        echo -e "\n\n\n\n\n\n\n\n"  # Espace pour la bannière
        
         
        print_styled "PRIMARY" "0) $(get_message "GUIDE" "HOW TO")"
        
        echo -e "\033[38;5;208m$(get_message "Menu Principal:" "Main Menu:")${COLORS[RESET]}"
        print_styled "PRIMARY" "1) $(get_message "Mise à jour système" "Update system")"
        print_styled "PRIMARY" "2) $(get_message "Installer Monero CLI" "Install Monero CLI")"
        print_styled "PRIMARY" "3) $(get_message "Installer service Tor" "Install configure Tor")"
        print_styled "PRIMARY" "4) $(get_message "Configurer bitmonero" "Configure bitmonero")"
        print_styled "PRIMARY" "5) $(get_message "Configurer DNS anonymes" "Configure anonymous DNS")"
        
        echo -e "\033[38;5;208m$(get_message "BLOCKCHAIN" "BLOCKCHAIN")${COLORS[RESET]}"
        print_styled "PRIMARY" "6) $(get_message "MARCHE" "START")"
        print_styled "PRIMARY" "7) $(get_message "ARRET= ctrl+c" "STOP= ctrl+c")"
        
        echo -e "\033[38;5;208m$(get_message "Option du Noeud sur Disque:" "Node Option on DISK:")${COLORS[RESET]}"
        
        print_styled "PRIMARY" "8) $(get_message "Blockchain sur DISQUE EXTERNE" "Blockchain on EXTERNAL DISK")"
        print_styled "PRIMARY" "9) $(get_message "Blockchain sur DISQUE INTERNE" "Blockchain on INTERNAL DISK")"
        
        echo -e "\033[38;5;208m$(get_message "AUTRES OPTIONS" "OTHER OPTIONS")${COLORS[RESET]}"
        print_styled "PRIMARY" "10) $(get_message "Changer language" "Change language")"
        print_styled "PRIMARY" "11) $(get_message "INFOS" "FEATURES")"
        print_styled "PRIMARY" "12) $(get_message "NOTES" "READ")"
        
        echo -e "\033[38;5;208m$(get_message "FIN" "END")${COLORS[RESET]}"
        print_styled "PRIMARY" "13) $(get_message "QUITTER" "EXIT")"
                
        echo -n "$(print_styled "INFO" "$(get_message "Choix (1-13): " "Choice (1-13): ")")"
        read -r choice

        case $choice in
              
            0) 
                Manuel
                ;;
            1) 
                update_system 
                ;;
            2)  
                if ! ask_username; then
                    continue
                fi
               
                install_monero_cli
                read -p "$(print_styled "PRIMARY" "$(get_message "Appuyez sur Entrée pour continuer..." "Press Enter to continue...")")"
                ;;
            3)  
                if ! ask_username; then
                    continue
                fi
                install_tor
                ;;
            4)  
                if ! ask_username; then
                    continue
                fi
                configure_monero
                ;;
            5) 
                configure_dns 
                ;;
            6) 
                if ! ask_username; then
                    continue
                fi
                start_blockchain
                ;;
            7) 
        echo -n "$(print_styled "INFO" "$(get_message "Voulez-vous vraiment arrêter la blockchain? (o/n): " "Do you really want to stop the blockchain? (y/n): ")")"
read -r confirm
case $confirm in
    [OoYy]*)
        pkill -f monerod
        sudo systemctl stop haproxy-monero
        sudo systemctl stop monero-decoy
        sudo systemctl stop monero
        
        # Vérification que tout est bien arrêté
        if pgrep -f monerod > /dev/null; then
            warning "$(get_message "Certains processus persistent, forçage de l'arrêt..." "Some processes still running, forcing shutdown...")"
            pkill -9 -f monerod
        fi
        
        success "$(get_message "Blockchain arrêtée" "Blockchain stopped")"
        ;;

        *)
                        continue
                        ;;
                esac
                ;;
            8)
                if ! ask_username; then
                    continue
                fi
                manage_blockchain
                ;;
            9) 
                unmount_sdb1 
                ;;
            10) 
                select_language
                continue
                ;;
            11) 
                show_scripts 
                ;;
            12) 
                 
                show_notes 
                ;;
            13) 
                    clear
                     if ! monero_animation; then
                    continue
                fi
    # Lancer l'animation
    #monero_animation
    setup_terminal
    echo -e "\n\n\n\n\n\n\n\n"  # Espace pour la bannière
    print_header "$(get_message "MERCI" "THANK YOU")"
    
    echo
    print_styled "SUCCESS" "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    if [ "$LANG_CHOICE" = "FR" ]; then
        print_styled "SUCCESS" "┃                                                                             ┃"
        print_styled "SUCCESS" "┃  Programme d'aide informatique et de liberté.                               ┃"
        print_styled "SUCCESS" "┃  Permet d'installer un nœud MONERO sans aucune connaissance sur Linux.      ┃"
        print_styled "SUCCESS" "┃                                                                             ┃"
        print_styled "SUCCESS" "┃  Merci d'avoir utilisé ce programme.                                        ┃"
        print_styled "SUCCESS" "┃                                                                             ┃"
        print_styled "MONERO"  "┃                           🔒 PRIVACY MATTERS 🔒                             ┃"
    else
        print_styled "SUCCESS" "┃                                                                             ┃"
        print_styled "SUCCESS" "┃  Computer assistance and freedom program.                                   ┃"
        print_styled "SUCCESS" "┃  Helps you install a MONERO node without any knowledge on Linux.            ┃"
        print_styled "SUCCESS" "┃                                                                             ┃"
        print_styled "SUCCESS" "┃  Thank you for using this program.                                          ┃"
        print_styled "SUCCESS" "┃                                                                             ┃"
        print_styled "MONERO"  "┃                           🔒 PRIVACY MATTERS 🔒                             ┃"
    fi
    print_styled "SUCCESS" "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"
    echo
      
    # Pause de 3 secondes avant de quitter
    sleep 3
    exit 0
    ;;
        esac
    done
}

# Point d'entrée du script
setup_terminal
select_language
show_menu
exit 0
